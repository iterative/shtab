{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<ul> <li>What: Automatically generate shell tab completion scripts for Python CLI apps</li> <li>Why: Speed &amp; correctness. Alternatives like   argcomplete and   pyzshcomplete are slow and have side-effects</li> <li>How: <code>shtab</code> processes an <code>argparse.ArgumentParser</code> object to generate a tab completion script for your shell</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Outputs tab completion scripts for<ul> <li><code>bash</code></li> <li><code>zsh</code></li> <li><code>tcsh</code></li> </ul> </li> <li>Supports<ul> <li>argparse</li> <li>docopt (via argopt)</li> </ul> </li> <li>Supports arguments, options and subparsers</li> <li>Supports choices (e.g. <code>--say={hello,goodbye}</code>)</li> <li>Supports file and directory path completion</li> <li>Supports custom path completion (e.g. <code>--file={*.txt}</code>)</li> </ul>"},{"location":"#installation","title":"Installation","text":"pipconda <pre><code>pip install shtab\n</code></pre> <pre><code>conda install -c conda-forge shtab\n</code></pre> <p><code>bash</code> users who have never used any kind of tab completion before should also follow the OS-specific instructions below.</p> Ubuntu/DebianMacOS <p>Recent versions should have completion already enabled. For older versions, first run <code>sudo apt install --reinstall bash-completion</code>, then make sure these lines appear in <code>~/.bashrc</code>:</p> <pre><code># enable bash completion in interactive shells\nif ! shopt -oq posix; then\n  if [ -f /usr/share/bash-completion/bash_completion ]; then\n    . /usr/share/bash-completion/bash_completion\n  elif [ -f /etc/bash_completion ]; then\n    . /etc/bash_completion\n  fi\nfi\n</code></pre> <p>First run <code>brew install bash-completion</code>, then add the following to <code>~/.bash_profile</code>:</p> <pre><code>if [ -f $(brew --prefix)/etc/bash_completion ]; then\n  . $(brew --prefix)/etc/bash_completion\nfi\n</code></pre>"},{"location":"#faqs","title":"FAQs","text":"<p>Not working?</p> <ul> <li>Make sure that <code>shtab</code> and the application you're trying to complete are both accessible from your environment.</li> <li>Make sure that <code>prog</code> is set:<ul> <li>if using <code>options.entry_points.console_scripts=MY_PROG=...</code>, then ensure the main parser's <code>prog</code> matches <code>argparse.ArgumentParser(prog=\"MY_PROG\")</code> or override it using <code>shtab MY_PROG.get_main_parser --prog=MY_PROG</code>.</li> <li>if executing a script file <code>./MY_PROG.py</code> (with a shebang <code>#!/usr/bin/env python</code>) directly, then use <code>argparse.ArgumentParser(prog=\"MY_PROG.py\")</code> or override it using <code>shtab MY_PROG.get_main_parser --prog=MY_PROG.py</code>.</li> </ul> </li> <li>Make sure that all arguments have <code>help</code> messages (<code>parser.add_argument('positional', help=\"documented; i.e. not hidden\")</code>).</li> <li>Ask a general question on StackOverflow.</li> <li>Report bugs and open feature requests on GitHub.</li> </ul> <p>\"Eager\" installation (completions are re-generated upon login/terminal start) is recommended. Naturally, <code>shtab</code> and the CLI application to complete should be accessible/importable from the login environment. If installing <code>shtab</code> in a different virtual environment, you'd have to add a line somewhere appropriate (e.g. <code>$CONDA_PREFIX/etc/conda/activate.d/env_vars.sh</code>).</p> <p>By default, <code>shtab</code> will silently do nothing if it cannot import the requested application. Use <code>-u, --error-unimportable</code> to noisily complain.</p>"},{"location":"#alternatives","title":"Alternatives","text":"<ul> <li>argcomplete<ul> <li>executes the underlying script every time <code>&lt;TAB&gt;</code> is pressed (slow and has side-effects)</li> <li>only provides <code>bash</code> completion</li> </ul> </li> <li>pyzshcomplete<ul> <li>executes the underlying script every time <code>&lt;TAB&gt;</code> is pressed (slow and has side-effects)</li> <li>only provides <code>zsh</code> completion</li> </ul> </li> <li>click<ul> <li>different framework completely replacing the builtin <code>argparse</code></li> <li>solves multiple problems (rather than POSIX-style \"do one thing well\")</li> </ul> </li> </ul>"},{"location":"#contributions","title":"Contributions","text":"<p>Please do open issues &amp; pull requests! Some ideas:</p> <ul> <li>support <code>fish</code></li> <li>support <code>powershell</code></li> </ul> <p>See CONTRIBUTING.md for more guidance.</p> <p></p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#tests","title":"Tests","text":"<p>When contributing pull requests, it's a good idea to run basic checks locally:</p> <pre><code># install development dependencies\nshtab (main)$ pip install pre-commit -e .[dev]\nshtab (main)$ pre-commit install  # install pre-commit checks\nshtab (main)$ pytest              # run all tests\n</code></pre>"},{"location":"contributing/#layout","title":"Layout","text":"<p>Most of the magic lives in <code>shtab/__init__.py</code>.</p> <ul> <li>shtab/</li> <li><code>__init__.py</code><ul> <li><code>complete()</code> - primary API, calls shell-specific versions</li> <li><code>complete_bash()</code></li> <li><code>complete_zsh()</code></li> <li><code>complete_tcsh()</code></li> <li>...</li> <li><code>add_argument_to()</code> - convenience function for library integration</li> <li><code>Optional()</code>, <code>Required()</code>, <code>Choice()</code> - legacy helpers for advanced completion (e.g. dirs, files, <code>*.txt</code>)</li> </ul> </li> <li><code>main.py</code><ul> <li><code>get_main_parser()</code> - returns <code>shtab</code>'s own parser object</li> <li><code>main()</code> - <code>shtab</code>'s own CLI application</li> </ul> </li> </ul> <p>Given that the number of completions a program may need would likely be less than a million, the focus is on readability rather than premature speed optimisations. The generated code itself, on the other had, should be fast.</p> <p>Helper functions such as <code>replace_format</code> allows use of curly braces <code>{}</code> in string snippets without clashing between Python's <code>str.format</code> and shell parameter expansion.</p> <p>The generated shell code itself is also meant to be readable.</p>"},{"location":"contributing/#releases","title":"Releases","text":"<p>Tests and deployment are handled automatically by continuous integration. Simply tag a commit <code>v{major}.{minor}.{patch}</code> and wait for a draft release to appear at https://github.com/iterative/shtab/releases. Tidy up the draft's description before publishing it.</p>"},{"location":"licence/","title":"Licence","text":"<p>Copyright 2020-2023 Casper da Costa-Luis</p> <p>Licensed under the Apache Licence, Version 2.0 (the \"Licence\"); you may not use this project except in compliance with the Licence. You may obtain a copy of the Licence at</p> <p>http://www.apache.org/licenses/LICENSE-2.0</p> <p>Unless required by applicable law or agreed to in writing, software distributed under the Licence is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the Licence for the specific language governing permissions and limitations under the Licence.</p>"},{"location":"ref/","title":"Reference","text":""},{"location":"ref/#shtab","title":"shtab","text":""},{"location":"ref/#complete","title":"complete","text":"<pre><code>def complete(parser: ArgumentParser,\n             shell: str = \"bash\",\n             root_prefix: Opt[str] = None,\n             preamble: Union[str, Dict[str, str]] = \"\",\n             choice_functions: Opt[Any] = None) -&gt; str\n</code></pre> <ul> <li>shell:   bash/zsh/tcsh</li> <li>root_prefix:   prefix for shell functions to avoid clashes (default: \"_{parser.prog}\")</li> <li>preamble:   mapping shell to text to prepend to generated script   (e.g. <code>{\"bash\": \"_myprog_custom_function(){ echo hello }\"}</code>)</li> <li>choice_functions:   deprecated</li> </ul> <p>N.B. <code>parser.add_argument().complete = ...</code> can be used to define custom completions (e.g. filenames). See examples/pathcomplete.py.</p> <p></p>"},{"location":"ref/#add_argument_to","title":"add_argument_to","text":"<pre><code>def add_argument_to(parser: ArgumentParser,\n                    option_string: Union[str,\n                                         List[str]] = \"--print-completion\",\n                    help: str = \"print shell completion script\",\n                    parent: Opt[ArgumentParser] = None,\n                    preamble: Union[str, Dict[str, str]] = \"\")\n</code></pre> <ul> <li>option_string:   iff positional (no <code>-</code> prefix) then <code>parser</code> is assumed to actually be   a subparser (subcommand mode)</li> <li>parent:   required in subcommand mode</li> </ul>"},{"location":"use/","title":"Usage","text":"<p>There are two ways of using <code>shtab</code>:</p> <ul> <li>CLI Usage: <code>shtab</code>'s own CLI interface for external applications<ul> <li>may not require any code modifications whatsoever</li> <li>end-users execute <code>shtab your_cli_app.your_parser_object</code></li> </ul> </li> <li>Library Usage: as a library integrated into your CLI application<ul> <li>adds a couple of lines to your application</li> <li>argument mode: end-users execute <code>your_cli_app --print-completion {bash,zsh,tcsh}</code></li> <li>subparser mode: end-users execute <code>your_cli_app completion {bash,zsh,tcsh}</code></li> </ul> </li> </ul>"},{"location":"use/#cli-usage","title":"CLI Usage","text":"<p>The only requirement is that external CLI applications provide an importable <code>argparse.ArgumentParser</code> object (or alternatively an importable function which returns a parser object). This may require a trivial code change.</p> <p>Once that's done, simply put the output of <code>shtab --shell=your_shell your_cli_app.your_parser_object</code> somewhere your shell looks for completions.</p> <p>Below are various examples of enabling <code>shtab</code>'s own tab completion scripts.</p> <p>Info</p> <p>If both shtab and the module it's completing are globally importable, eager usage is an option. \"Eager\" means automatically updating completions each time a terminal is opened.</p> bashEager bashzshEager zshtcshEager tcsh <pre><code>shtab --shell=bash shtab.main.get_main_parser --error-unimportable \\\n  | sudo tee \"$BASH_COMPLETION_COMPAT_DIR\"/shtab\n</code></pre> <p>There are a few options:</p> <pre><code># Install locally\necho 'eval \"$(shtab --shell=bash shtab.main.get_main_parser)\"' \\\n  &gt;&gt; ~/.bash_completion\n\n# Install locally (lazy load for bash-completion&gt;=2.8)\necho 'eval \"$(shtab --shell=bash shtab.main.get_main_parser)\"' \\\n  &gt; \"${BASH_COMPLETION_USER_DIR:-${XDG_DATA_HOME:-$HOME/.local/share}/bash-completion}/completions/shtab\"\n\n# Install system-wide\necho 'eval \"$(shtab --shell=bash shtab.main.get_main_parser)\"' \\\n  | sudo tee \"$(pkg-config --variable=completionsdir bash-completion)\"/shtab\n\n# Install system-wide (legacy)\necho 'eval \"$(shtab --shell=bash shtab.main.get_main_parser)\"' \\\n  | sudo tee \"$BASH_COMPLETION_COMPAT_DIR\"/shtab\n</code></pre> <p>Note that <code>zsh</code> requires completion script files to be named <code>_{EXECUTABLE}</code> (with an underscore prefix).</p> <pre><code># note the underscore `_` prefix\nshtab --shell=zsh shtab.main.get_main_parser --error-unimportable \\\n  | sudo tee /usr/local/share/zsh/site-functions/_shtab\n</code></pre> <p>To be more eager, place the generated script somewhere in <code>$fpath</code>. For example, add these lines to the top of <code>~/.zshrc</code>:</p> <pre><code>mkdir -p ~/.zsh/completions\nfpath=($fpath ~/.zsh/completions)  # must be before `compinit` lines\nshtab --shell=zsh shtab.main.get_main_parser &gt; ~/.zsh/completions/_shtab\n</code></pre> <pre><code>shtab --shell=tcsh shtab.main.get_main_parser --error-unimportable \\\n  | sudo tee /etc/profile.d/shtab.completion.csh\n</code></pre> <p>There are a few options:</p> <pre><code># Install locally\necho 'shtab --shell=tcsh shtab.main.get_main_parser | source /dev/stdin' \\\n  &gt;&gt; ~/.cshrc\n\n# Install system-wide\necho 'shtab --shell=tcsh shtab.main.get_main_parser | source /dev/stdin' \\\n  | sudo tee /etc/profile.d/eager-completion.csh\n</code></pre> <p>Tip</p> <p>See the examples/ folder for more.</p> <p>Any existing <code>argparse</code>-based scripts should be supported with minimal effort. For example, starting with this existing code:</p> main.py<pre><code>#!/usr/bin/env python\nimport argparse\n\ndef get_main_parser():\n    parser = argparse.ArgumentParser(prog=\"MY_PROG\", ...)\n    parser.add_argument(...)\n    parser.add_subparsers(...)\n    ...\n    return parser\n\nif __name__ == \"__main__\":\n    parser = get_main_parser()\n    args = parser.parse_args()\n    ...\n</code></pre> <p>Assuming this code example is installed in <code>MY_PROG.command.main</code>, simply run:</p> bashzshtcsh <pre><code>shtab --shell=bash -u MY_PROG.command.main.get_main_parser \\\n  | sudo tee \"$BASH_COMPLETION_COMPAT_DIR\"/MY_PROG\n</code></pre> <pre><code>shtab --shell=zsh -u MY_PROG.command.main.get_main_parser \\\n  | sudo tee /usr/local/share/zsh/site-functions/_MY_PROG\n</code></pre> <pre><code>shtab --shell=tcsh -u MY_PROG.command.main.get_main_parser \\\n  | sudo tee /etc/profile.d/MY_PROG.completion.csh\n</code></pre>"},{"location":"use/#library-usage","title":"Library Usage","text":"<p>Tip</p> <p>See the examples/ folder for more.</p> <p>Complex projects with subparsers and custom completions for paths matching certain patterns (e.g. <code>--file=*.txt</code>) are fully supported (see examples/customcomplete.py or even iterative/dvc:commands/completion.py for example).</p> <p>Add direct support to scripts for a little more configurability:</p> argparsedocopt pathcomplete.py<pre><code>#!/usr/bin/env python\nimport argparse\nimport shtab  # for completion magic\n\ndef get_main_parser():\n    parser = argparse.ArgumentParser(prog=\"pathcomplete\")\n    shtab.add_argument_to(parser, [\"-s\", \"--print-completion\"])  # magic!\n    # file &amp; directory tab complete\n    parser.add_argument(\"file\", nargs=\"?\").complete = shtab.FILE\n    parser.add_argument(\"--dir\", default=\".\").complete = shtab.DIRECTORY\n    return parser\n\nif __name__ == \"__main__\":\n    parser = get_main_parser()\n    args = parser.parse_args()\n    print(\"received &lt;file&gt;=%r --dir=%r\" % (args.file, args.dir))\n</code></pre> <p>Simply use argopt to create a parser object from docopt syntax:</p> docopt-greeter.py<pre><code>#!/usr/bin/env python\n\"\"\"Greetings and partings.\n\nUsage:\n  greeter [options] [&lt;you&gt;] [&lt;me&gt;]\n\nOptions:\n  -g, --goodbye  : Say \"goodbye\" (instead of \"hello\")\n\nArguments:\n  &lt;you&gt;  : Your name [default: Anon]\n  &lt;me&gt;  : My name [default: Casper]\n\"\"\"\nimport argopt, shtab\n\nparser = argopt.argopt(__doc__)\nshtab.add_argument_to(parser, [\"-s\", \"--print-completion\"])  # magic!\nif __name__ == \"__main__\":\n    args = parser.parse_args()\n    msg = \"k thx bai!\" if args.goodbye else \"hai!\"\n    print(\"{} says '{}' to {}\".format(args.me, msg, args.you))\n</code></pre>"}]}